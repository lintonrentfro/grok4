<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Star Trek Game with Foundation</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/foundation-sites@6.8.1/dist/css/foundation.min.css" crossorigin="anonymous">
    <style>
        canvas { background: white; display: block; border: 3px solid black; }
        .callout { border: 3px solid gray; width: 200px; height: 600px; box-sizing: border-box; margin-right: 20px; }
        body { background: #fefefe; margin-top: 20px; } /* Foundation default light bg */
        .game-container { display: flex; justify-content: center; align-items: flex-start; }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="callout">
            <div class="grid-y grid-padding-y" style="height: 100%;">
                <div class="cell auto">
                    <p>Rules: You are the Enterprise. Navigate through space to the Tribble. Avoid asteroids. Use arrow keys: Up - forward, Down - backward, Left - turn left, Right - turn right. Reach the Tribble to win!</p>
                </div>
                <div class="cell shrink text-center">
                    <button id="fireButton" class="button primary" onclick="fireTorpedo()">Fire Torpedo</button>
                </div>
            </div>
        </div>
        <canvas id="game" width="950" height="600"></canvas>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/foundation-sites@6.8.1/dist/js/foundation.min.js" crossorigin="anonymous"></script>
    <script>
        $(document).foundation();
    </script>

    <script>
        const WIDTH = 20;
        const HEIGHT = 15;
        const CANVAS_WIDTH = 950;
        const CANVAS_HEIGHT = 600;
        const ENTERPRISE = 'E';
        const ASTEROID = '*';
        const GOAL = 'G';
        const KLINGON = 'K';
        const EMPTY = ' ';

        let grid;
        let playerX;
        let playerY;
        let goalX;
        let goalY;
        let klingonX;
        let klingonY;
        let klingonFacing;
        let cloaked;
        let facing = 0; // 0: up, 1: right, 2: down, 3: left
        let gameState = 'ready';
        let hasStarted = false;
        let movingAsteroids = [];
        let playerMoves = 0;
        let torpedoes = 3;
        let firing = false;
        let torpedoPos;
        let targetPos;
        let dirX;
        let dirY;
        let animationId;
        let movesSinceLastFire = 0;
        let torpedoTargets = [];
        let loseReason = 'asteroid';

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const cellWidth = CANVAS_WIDTH / WIDTH;
        const cellHeight = CANVAS_HEIGHT / HEIGHT;
        const fireButton = document.getElementById('fireButton');

        let enterpriseImg;
        let tempImg = new Image();
        tempImg.src = 'https://lintonrentfro.github.io/grok4/images/enterprise.png';
        tempImg.onload = function() {
          let offCanvas = document.createElement('canvas');
          offCanvas.width = tempImg.height;
          offCanvas.height = tempImg.width;
          let offCtx = offCanvas.getContext('2d');
          offCtx.translate(offCanvas.width / 2, offCanvas.height / 2);
          offCtx.rotate(-Math.PI / 2);
          offCtx.drawImage(tempImg, -tempImg.width / 2, -tempImg.height / 2);
          enterpriseImg = new Image();
          enterpriseImg.src = offCanvas.toDataURL();
          enterpriseImg.onload = draw;
        };

        let rockImg = new Image();
        rockImg.src = 'https://lintonrentfro.github.io/grok4/images/rock.png';

        let tribbleImg = new Image();
        tribbleImg.src = 'https://lintonrentfro.github.io/grok4/images/tribble.png';

        let klingonImg = new Image();
        klingonImg.src = 'https://lintonrentfro.github.io/grok4/images/klingon.png';

        // Redraw when images load
        rockImg.onload = draw;
        tribbleImg.onload = draw;
        klingonImg.onload = draw;

        function initGame() {
            grid = Array.from({length: HEIGHT}, () => Array(WIDTH).fill(EMPTY));

            // Player on left edge, random Y
            playerX = 0;
            playerY = Math.floor(Math.random() * HEIGHT);

            // Goal on right edge, random Y
            goalX = WIDTH - 1;
            goalY = Math.floor(Math.random() * HEIGHT);

            // Place random asteroids
            for (let i = 0; i < 20; i++) {
                let ax = Math.floor(Math.random() * WIDTH);
                let ay = Math.floor(Math.random() * HEIGHT);
                if ((ax !== playerX || ay !== playerY) && (ax !== goalX || ay !== goalY)) {
                    grid[ay][ax] = ASTEROID;
                }
            }

            // Place Klingon
            let dist;
            do {
                klingonX = Math.floor(Math.random() * WIDTH);
                klingonY = Math.floor(Math.random() * HEIGHT);
                dist = Math.abs(klingonX - playerX) + Math.abs(klingonY - playerY);
            } while (grid[klingonY][klingonX] !== EMPTY || dist <= 6 || (klingonX === goalX && klingonY === goalY));
            grid[klingonY][klingonX] = KLINGON;
            klingonFacing = Math.floor(Math.random() * 4);
            cloaked = true;

            grid[playerY][playerX] = ENTERPRISE;
            grid[goalY][goalX] = GOAL;

            // Select more moving asteroids (6)
            let asteroidPositions = [];
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    if (grid[y][x] === ASTEROID) {
                        asteroidPositions.push({x, y});
                    }
                }
            }
            asteroidPositions.sort(() => Math.random() - 0.5);
            const selected = asteroidPositions.slice(0, 6);
            const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]];
            movingAsteroids = selected.map((pos, index) => {
                const dirIndex = Math.floor(Math.random() * 4);
                const dir = directions[dirIndex];
                return {x: pos.x, y: pos.y, dx: dir[0], dy: dir[1], interval: index < 3 ? 2 : 3};
            });

            playerMoves = 0;
            torpedoes = 3;
            firing = false;
            facing = 1; // Face right, towards the goal
            movesSinceLastFire = 0;
            torpedoTargets = [];
            loseReason = 'asteroid';
            fireButton.disabled = true;
            if (animationId) cancelAnimationFrame(animationId);
            gameState = hasStarted ? 'playing' : 'ready';
            document.addEventListener('keydown', handleKey);
            updateFireButton();
            draw();
        }

        function drawGrid(faded = false) {
            if (faded) {
                ctx.globalAlpha = 0.3;
            }
            ctx.fillStyle = 'black';
            ctx.font = '30px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    let char = grid[y][x];
                    if (char === ENTERPRISE) {
                        if (enterpriseImg && enterpriseImg.complete) {
                            let imgW = enterpriseImg.width;
                            let imgH = enterpriseImg.height;
                            let centerX = x * cellWidth + cellWidth / 2;
                            let centerY = y * cellHeight + cellHeight / 2;
                            ctx.save();
                            ctx.translate(centerX, centerY);
                            ctx.rotate(facing * Math.PI / 2);
                            ctx.drawImage(enterpriseImg, -imgW / 2, -imgH / 2, imgW, imgH);
                            ctx.restore();
                        } else {
                            ctx.fillText('@', x * cellWidth + cellWidth / 2, y * cellHeight + cellHeight / 2);
                        }
                    } else if (char === ASTEROID) {
                        if (rockImg.complete) {
                            let imgW = rockImg.width;
                            let imgH = rockImg.height;
                            ctx.drawImage(rockImg, x * cellWidth + (cellWidth - imgW) / 2, y * cellHeight + (cellHeight - imgH) / 2, imgW, imgH);
                        } else {
                            ctx.fillText('*', x * cellWidth + cellWidth / 2, y * cellHeight + cellHeight / 2);
                        }
                    } else if (char === GOAL) {
                        if (tribbleImg.complete) {
                            let imgW = tribbleImg.width;
                            let imgH = tribbleImg.height;
                            ctx.drawImage(tribbleImg, x * cellWidth + (cellWidth - imgW) / 2, y * cellHeight + (cellHeight - imgH) / 2, imgW, imgH);
                        } else {
                            ctx.fillText('G', x * cellWidth + cellWidth / 2, y * cellHeight + cellHeight / 2);
                        }
                    } else if (char === KLINGON) {
                        if (cloaked) continue;
                        if (klingonImg.complete) {
                            let imgW = klingonImg.width;
                            let imgH = klingonImg.height;
                            let centerX = x * cellWidth + cellWidth / 2;
                            let centerY = y * cellHeight + cellHeight / 2;
                            ctx.save();
                            ctx.translate(centerX, centerY);
                            ctx.rotate(klingonFacing * Math.PI / 2);
                            ctx.drawImage(klingonImg, -imgW / 2, -imgH / 2, imgW, imgH);
                            ctx.restore();
                        } else {
                            ctx.fillText('K', x * cellWidth + cellWidth / 2, y * cellHeight + cellHeight / 2);
                        }
                    }
                }
            }
            if (faded) {
                ctx.globalAlpha = 1.0;
            }
        }

        function draw() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (gameState === 'ready') {
                drawGrid(false);
                ctx.fillStyle = 'black';
                ctx.font = '50px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Press arrow key to start!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            } else if (gameState === 'playing') {
                drawGrid(false);
            } else {
                drawGrid(true);
                ctx.fillStyle = 'black';
                ctx.font = '50px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let message;
                if (gameState === 'won') {
                    message = 'You found the tribble! Press arrow key to restart!';
                } else if (loseReason === 'asteroid') {
                    message = 'You hit an asteroid and exploded! Press arrow key to restart!';
                } else if (loseReason === 'tribble') {
                    message = 'You destroyed the Tribble! Press arrow key to restart!';
                } else if (loseReason === 'klingon_torpedo') {
                    message = 'You were hit by a Klingon torpedo! Press arrow key to restart!';
                } else if (loseReason === 'klingon_collision') {
                    message = 'You collided with a Klingon ship! Press arrow key to restart!';
                }
                ctx.fillText(message, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            }
        }

        function moveAsteroids() {
            playerMoves++;
            let newMovingAsteroids = [];
            movingAsteroids.forEach(ast => {
                if (playerMoves % ast.interval !== 0) {
                    newMovingAsteroids.push(ast);
                    return;
                }
                let newX = ast.x + ast.dx;
                let newY = ast.y + ast.dy;
                if (newX < 0 || newX >= WIDTH || newY < 0 || newY >= HEIGHT) {
                    grid[ast.y][ast.x] = EMPTY;
                    return;
                }
                let target = grid[newY][newX];
                if (target === EMPTY) {
                    grid[ast.y][ast.x] = EMPTY;
                    grid[newY][newX] = ASTEROID;
                    ast.x = newX;
                    ast.y = newY;
                    newMovingAsteroids.push(ast);
                } else if (target === ENTERPRISE) {
                    loseReason = 'asteroid';
                    gameState = 'gameover';
                } else if (target === GOAL) {
                    grid[ast.y][ast.x] = EMPTY;
                    return;
                } else if (target === ASTEROID) {
                    if (Math.random() < 0.5) {
                        // Moving asteroid disappears
                        grid[ast.y][ast.x] = EMPTY;
                    } else {
                        // Destroy target, moving takes place
                        grid[ast.y][ast.x] = EMPTY;
                        grid[newY][newX] = ASTEROID;
                        ast.x = newX;
                        ast.y = newY;
                        newMovingAsteroids.push(ast);
                    }
                } else if (target === KLINGON) {
                    grid[ast.y][ast.x] = EMPTY;
                    return;
                }
            });
            movingAsteroids = newMovingAsteroids;
        }

        function turnLeft() {
            facing = (facing - 1 + 4) % 4;
            draw();
        }

        function turnRight() {
            facing = (facing + 1) % 4;
            draw();
        }

        function moveForward() {
            let dx = 0, dy = 0;
            if (facing === 0) dy = -1;
            else if (facing === 1) dx = 1;
            else if (facing === 2) dy = 1;
            else if (facing === 3) dx = -1;
            move(dx, dy);
        }

        function moveBackward() {
            let dx = 0, dy = 0;
            if (facing === 0) dy = 1;
            else if (facing === 1) dx = -1;
            else if (facing === 2) dy = -1;
            else if (facing === 3) dx = 1;
            move(dx, dy);
        }

        function move(dx, dy) {
            let newX = playerX + dx;
            let newY = playerY + dy;
            if (newX < 0 || newX >= WIDTH || newY < 0 || newY >= HEIGHT) return;
            let target = grid[newY][newX];
            if (target === ASTEROID) {
                loseReason = 'asteroid';
                gameState = 'gameover';
                draw();
                return;
            }
            if (target === KLINGON) {
                loseReason = 'klingon_collision';
                gameState = 'gameover';
                draw();
                return;
            }
            if (target === GOAL) {
                gameState = 'won';
                draw();
                return;
            }
            grid[playerY][playerX] = EMPTY;
            playerX = newX;
            playerY = newY;
            grid[playerY][playerX] = ENTERPRISE;
            if (Math.random() < 0.5) {
                spawnAsteroid();
            }
            if (Math.random() < 0.25) {
                let current_dist = Math.abs(goalX - playerX) + Math.abs(goalY - playerY);
                let possible_moves = [];
                const dirs = [[0, -1], [0, 1], [-1, 0], [1, 0]];
                for (let d of dirs) {
                    let nx = goalX + d[0];
                    let ny = goalY + d[1];
                    if (nx >= 0 && nx < WIDTH && ny >= 0 && ny < HEIGHT && grid[ny][nx] === EMPTY) {
                        let new_dist = Math.abs(nx - playerX) + Math.abs(ny - playerY);
                        if (new_dist > current_dist) {
                            possible_moves.push({x: nx, y: ny});
                        }
                    }
                }
                if (possible_moves.length > 0) {
                    let chosen = possible_moves[Math.floor(Math.random() * possible_moves.length)];
                    grid[goalY][goalX] = EMPTY;
                    goalX = chosen.x;
                    goalY = chosen.y;
                    grid[goalY][goalX] = GOAL;
                }
            }
            moveAsteroids();
            movesSinceLastFire++;
            draw();
            updateFireButton();
        }

        function updateKlingon() {
            if (klingonX < 0) return;

            let dx = playerX - klingonX;
            let dy = playerY - klingonY;
            let preferredFacing;
            if (Math.abs(dx) >= Math.abs(dy)) {
                preferredFacing = dx > 0 ? 1 : 3;
            } else {
                preferredFacing = dy > 0 ? 2 : 0;
            }

            let diff = (preferredFacing - klingonFacing + 4) % 4;
            if (diff !== 0) {
                if (diff === 1 || diff === 2) {
                    klingonFacing = (klingonFacing + 1) % 4; // turn right
                } else {
                    klingonFacing = (klingonFacing - 1 + 4) % 4; // turn left
                }
            } else {
                // try to move forward
                let kdx = 0, kdy = 0;
                if (klingonFacing === 0) kdy = -1;
                else if (klingonFacing === 1) kdx = 1;
                else if (klingonFacing === 2) kdy = 1;
                else if (klingonFacing === 3) kdx = -1;
                let newKX = klingonX + kdx;
                let newKY = klingonY + kdy;
                if (newKX >= 0 && newKX < WIDTH && newKY >= 0 && newKY < HEIGHT && grid[newKY][newKX] === EMPTY) {
                    grid[klingonY][klingonX] = EMPTY;
                    klingonX = newKX;
                    klingonY = newKY;
                    grid[klingonY][klingonX] = KLINGON;
                }
            }

            let dist = Math.abs(playerX - klingonX) + Math.abs(playerY - klingonY);
            if (dist <= 6) cloaked = false;
            if (dist <= 4) {
                for (let i = 0; i < 3; i++) {
                    if (Math.random() < 0.1) {
                        gameState = 'gameover';
                        loseReason = 'klingon_torpedo';
                        break;
                    }
                }
            }
        }

        function spawnAsteroid() {
            const edge = Math.floor(Math.random() * 4);
            let ax, ay, dx, dy;
            if (edge === 0) { // top
                ay = 0;
                ax = Math.floor(Math.random() * WIDTH);
                dy = 1;
                dx = 0;
            } else if (edge === 1) { // bottom
                ay = HEIGHT - 1;
                ax = Math.floor(Math.random() * WIDTH);
                dy = -1;
                dx = 0;
            } else if (edge === 2) { // left
                ax = 0;
                ay = Math.floor(Math.random() * HEIGHT);
                dx = 1;
                dy = 0;
            } else { // right
                ax = WIDTH - 1;
                ay = Math.floor(Math.random() * HEIGHT);
                dx = -1;
                dy = 0;
            }
            if (grid[ay][ax] === EMPTY) {
                grid[ay][ax] = ASTEROID;
                movingAsteroids.push({x: ax, y: ay, dx, dy, interval: Math.random() < 0.5 ? 2 : 3});
            }
        }

        function updateFireButton() {
            if (movesSinceLastFire >= 7) {
                fireButton.textContent = 'Fire Torpedo';
                fireButton.disabled = false;
            } else {
                fireButton.textContent = `Fire in ${7 - movesSinceLastFire} turns`;
                fireButton.disabled = true;
            }
        }

        function startFiring() {
            if (torpedoTargets.length === 0 || firing) return;
            let target = torpedoTargets.shift();
            firing = true;
            torpedoPos = {x: playerX * cellWidth + cellWidth / 2, y: playerY * cellHeight + cellHeight / 2};
            targetPos = {x: target.x * cellWidth + cellWidth / 2, y: target.y * cellHeight + cellHeight / 2};
            let dx = targetPos.x - torpedoPos.x;
            let dy = targetPos.y - torpedoPos.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            dirX = dx / dist;
            dirY = dy / dist;
            const speed = 20;
            function animateTorpedo() {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                drawGrid();
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(torpedoPos.x, torpedoPos.y, 5, 0, 2 * Math.PI);
                ctx.fill();
                torpedoPos.x += dirX * speed;
                torpedoPos.y += dirY * speed;
                let newDist = Math.sqrt((targetPos.x - torpedoPos.x)**2 + (targetPos.y - torpedoPos.y)**2);
                if (newDist < speed) {
                    if (target.isGoal) {
                        grid[goalY][goalX] = EMPTY;
                        goalX = -1;
                        goalY = -1;
                        loseReason = 'tribble';
                        gameState = 'gameover';
                        torpedoTargets = [];
                        draw();
                    } else if (target.x === klingonX && target.y === klingonY) {
                        if (Math.random() < 0.4) {
                            grid[target.y][target.x] = EMPTY;
                            klingonX = -1;
                        }
                    } else {
                        if (Math.random() < 0.4) {
                            grid[target.y][target.x] = EMPTY;
                            movingAsteroids = movingAsteroids.filter(a => !(a.x === target.x && a.y === target.y));
                        }
                    }
                    firing = false;
                    draw();
                    startFiring();
                } else {
                    animationId = requestAnimationFrame(animateTorpedo);
                }
            }
            animationId = requestAnimationFrame(animateTorpedo);
        }

        function fireTorpedo() {
            if (fireButton.disabled || gameState !== 'playing') return;
            let targets = [];
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    if (grid[y][x] === ASTEROID || (x === goalX && y === goalY) || (!cloaked && x === klingonX && y === klingonY)) {
                        let dist = Math.abs(x - playerX) + Math.abs(y - playerY);
                        if (dist > 0) {
                            targets.push({x, y, dist, isGoal: (x === goalX && y === goalY)});
                        }
                    }
                }
            }
            if (targets.length === 0) return;
            targets.sort((a, b) => a.dist - b.dist);
            torpedoTargets = targets.slice(0, 3);
            movesSinceLastFire = 0;
            updateFireButton();
            startFiring();
        }

        function handleKey(e) {
            if (firing) return;
            if ((gameState === 'gameover' || gameState === 'won') && (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                initGame();
                return;
            }
            if (gameState === 'ready' && (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                gameState = 'playing';
                hasStarted = true;
                draw();
                return;
            }
            if (gameState !== 'playing') return;
            if (e.key === 'Shift') {
                if (torpedoes <= 0) return;
                let targets = [];
                for (let y = 0; y < HEIGHT; y++) {
                    for (let x = 0; x < WIDTH; x++) {
                        if (grid[y][x] === ASTEROID || (x === goalX && y === goalY) || (!cloaked && x === klingonX && y === klingonY)) {
                            let dist = Math.abs(x - playerX) + Math.abs(y - playerY);
                            if (dist <= 5 && dist > 0) {
                                targets.push({x, y, dist, isGoal: (x === goalX && y === goalY)});
                            }
                        }
                    }
                }
                if (targets.length === 0) return;
                targets.sort((a, b) => a.dist - b.dist);
                let target = targets[0];
                torpedoes--;
                firing = true;
                torpedoPos = {x: playerX * cellWidth + cellWidth / 2, y: playerY * cellHeight + cellHeight / 2};
                targetPos = {x: target.x * cellWidth + cellWidth / 2, y: target.y * cellHeight + cellHeight / 2};
                let dx = targetPos.x - torpedoPos.x;
                let dy = targetPos.y - torpedoPos.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                dirX = dx / dist;
                dirY = dy / dist;
                const speed = 20;
                function animateTorpedo() {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                    drawGrid();
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(torpedoPos.x, torpedoPos.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                    torpedoPos.x += dirX * speed;
                    torpedoPos.y += dirY * speed;
                    let newDist = Math.sqrt((targetPos.x - torpedoPos.x)**2 + (targetPos.y - torpedoPos.y)**2);
                    if (newDist < speed) {
                        if (target.isGoal) {
                            grid[goalY][goalX] = EMPTY;
                            goalX = -1;
                            goalY = -1;
                            loseReason = 'tribble';
                            gameState = 'gameover';
                            draw();
                        } else if (target.x === klingonX && target.y === klingonY) {
                            if (Math.random() < 0.4) {
                                grid[target.y][target.x] = EMPTY;
                                klingonX = -1;
                            }
                        } else {
                            if (Math.random() < 0.4) {
                                grid[target.y][target.x] = EMPTY;
                                movingAsteroids = movingAsteroids.filter(a => !(a.x === target.x && a.y === target.y));
                            }
                        }
                        firing = false;
                        draw();
                    } else {
                        animationId = requestAnimationFrame(animateTorpedo);
                    }
                }
                animationId = requestAnimationFrame(animateTorpedo);
                return;
            }
            let actionTaken = false;
            switch (e.key) {
                case 'ArrowUp': moveForward(); actionTaken = true; break;
                case 'ArrowDown': moveBackward(); actionTaken = true; break;
                case 'ArrowLeft': turnLeft(); actionTaken = true; break;
                case 'ArrowRight': turnRight(); actionTaken = true; break;
                case ' ': fireTorpedo(); break;
            }
            if (actionTaken) {
                updateKlingon();
                draw();
            }
        }

        initGame();
    </script>
</body>
</html>